---
title: Arquitectura de búsqueda de catálogo
parent: References
---

<article class="bcls-article">
  <h1>Arquitectura de búsqueda de catálogo</h1>
  <summary>En este tema, aprenderá sobre la arquitectura de Brightcove para su tecnología de búsqueda de catálogos.</summary>
  <section class="bcls-section">
    <h2 id="Overview">Resumen</h2>
    <p >A partir de abril de 2019, la funcionalidad de búsqueda de catálogo se actualizó a Elasticsearch. Esta actualización proporciona una serie de beneficios, entre los que se encuentran la relevancia y la precisión mejoradas, y el rendimiento drásticamente mejorado: el tiempo de respuesta es mucho más consistente y generalmente el doble de rápido. Esta nueva funcionalidad afectará la API de CMS, la API de reproducción, la búsqueda interactiva de Studio y los métodos de búsqueda de catálogo.</p>
    <p >Si bien Brightcove ha invertido una cantidad sustancial de esfuerzo en hacer que los resultados de Elasticsearch sean consistentes, existen diferencias y existe una pequeña posibilidad de que si ha codificado dependencias específicas en los resultados de búsqueda, es posible que su integración no se comporte como se esperaba.</p>
  </section>
  <section class="bcls-section">
    <h2 id="Search_Result_Differences_and_Impact">Diferencias e impacto en los resultados de búsqueda</h2>
    <p >Al estudiar el impacto potencial, Brightcove descubrió que más del 90% de las búsquedas arrojan resultados que coinciden en términos de la cantidad de resultados devueltos. Este es un indicador de que los resultados esperados no deben ser lo suficientemente diferentes como para causar problemas con las integraciones de API.</p>
    <figure class="bcls-figure"><img class="bcls-image" alt="comparison" src="/assets/images/references/catalog-search/comparison.png" /></figure>
    <p >Este gráfico muestra el número de resultados de búsqueda que coinciden exactamente con el número de resultados entre los dos sistemas en azul y los que difieren en número en rojo.</p>
    <p >Como parte de nuestra implementación, Elasticsearch ya ha proporcionado todas las búsquedas predeterminadas, esas búsquedas en la cadena vacía, desde hace varios meses, por lo que los usuarios ya están viendo y usando los resultados de Elasticsearch sin problemas.</p>
    <p >Sin embargo, existen limitaciones a lo que podemos aprender de este tipo de comparación. En el mejor de los casos, solo podemos inferir la intención de una búsqueda en particular y los datos del catálogo son fluidos.</p>
  </section>
  <section class="bcls-section">
    <h2 id="Known_Differences">Diferencias conocidas</h2>
    <p >Las diferencias a continuación son en gran parte fundamentales, o el resultado de decisiones tomadas después de un análisis extenso de los resultados de búsqueda; son imposibles de eliminar por completo.</p>
    <h3>Derivado</h3>
    <p ><a href="https://en.wikipedia.org/wiki/Stemming">Derivado</a> es el proceso de reducir las palabras flexionadas (oa veces derivadas) a su <a href="https://en.wikipedia.org/wiki/Word_stem">tallo de la palabra</a> , base o <a href="https://en.wikipedia.org/wiki/Root_(linguistics)">raíz</a> forma - generalmente una forma de palabra escrita.</p>
    <p >Una lectora para inglés que opera en la potencia. <em>gato</em> debería identificar tales <a href="https://en.wikipedia.org/wiki/String_literal">instrumentos de cuerda</a> como <em>gatos</em>, <em>felino</em> y <em>malicioso</em>. Un algoritmo de derivación también podría reducir las palabras <em>pesca</em>, <em>pescado</em> y <em>pescador</em> al tallo <em>pez</em>. La raíz no necesita ser una palabra, por ejemplo, el algoritmo de Porter reduce <em>discutir</em>, <em>argumentó</em>, <em>argumenta</em>, <em>discutiendo</em> y <em>Argos</em> al tallo <em>argumentar</em>.</p>
    <p >Nuestra búsqueda actual utiliza el lematizador Lancaster (Paice / Husk), este algoritmo generalmente se considera demasiado agresivo; esto da como resultado una falta de distinción, por ejemplo <em>encendedor</em> y <em>luz</em> sería considerado como el mismo término en Lancaster.</p>
    <p >Elasticsearch utiliza un algoritmo más reciente y mucho menos agresivo (Porter2) que ha ganado una amplia adopción en la industria y generalmente se considera una mejora significativa (Lancaster ahora es poco común). El cambio de lematizador potencialmente impacta una proporción significativa (~ 35%) de búsquedas: eso no quiere decir que los resultados <strong>voluntad</strong> ser diferente, solo que ellos <strong>podría</strong> ser diferente, pero en general esto debería ser para mejor: dicho esto, algunos subconjuntos de clientes pueden depender del comportamiento anterior.</p>
    <h3>Relevancia</h3>
    <p >Nuestra búsqueda actual parece tener una normalización de TF más estricta. Esto provoca una clasificación de relevancia diferente para los términos que se encuentran en campos más grandes (es decir, existente considera que la coincidencia es menos relevante ya que le da menos peso al término ya que es más pequeño en relación con la longitud del documento).</p>
    <h3>Caracteres especiales</h3>
    <p >Los caracteres especiales se eliminan dentro de nuestra búsqueda existente, esto prácticamente equivale a eliminar la puntuación y los caracteres relacionados; en lugar de eliminarlos, generalmente los escapamos en Elasticsearch, por lo que existe la posibilidad de que una búsqueda los tenga en cuenta.</p>
    <h3>Manejo de términos</h3>
    <p >Las consultas de búsqueda existentes realizan "suavizado de términos" mientras que en Elasticsearch descartamos términos con formato incorrecto, considere esta búsqueda con un <code translate="No">tags:</code> término: <code translate="No">q=tags: state:ACTIVE</code></p>
    <ul>
      <li><strong>Existente</strong> : <code translate="No">tags:state:ACTIVE</code> - buscar videos con una etiqueta de <code translate="No">state:ACTIVE</code></li>
      <li><strong>Elasticsearch</strong> : <code translate="No">state:ACTIVE</code> - suelta el término vacío</li>
    </ul>
    <p >Hay una serie de casos sutiles relacionados con el manejo de la puntuación pendiente y las consultas que generalmente tienen un formato incorrecto, intentamos producir lo que pensamos que la consulta estaba destinada a ser, pero en estos casos, desafortunadamente, estamos adivinando lo que un usuario podría haber intentado ( cuando realmente deberíamos haber devuelto un error que les permitiera refinar su búsqueda)</p>
    <h3>Solo jugable</h3>
    <p >Existen dos mecanismos para restringir una búsqueda a los videos que se pueden reproducir actualmente: la consulta puede incluir una bandera o la consulta en sí puede requerir algún aspecto de la reproducción.</p>
    <ul>
      <li>Existente: se consulta en función del valor de un campo que se actualiza</li>
      <li>Elasticsearch: esto se consulta en función de los rangos de fechas calculados</li>
    </ul>
    <p >Elasticsearch generalmente debería ser más preciso y producir mejores resultados (hay un retraso asociado con el mecanismo existente y el mecanismo de mantenimiento de banderas no es del todo confiable).</p>
    <h3>Precisión del índice</h3>
    <p >El índice Elasticsearch es 'más reciente' que el índice existente y tiende a reflejar las actualizaciones más rápido; este no es siempre el caso, pero en general, la experiencia con Elasticsearch es que los resultados reflejarán con mayor precisión el estado de los datos del catálogo subyacente. Tanto el existente como Elasticsearch son sistemas distribuidos y, por lo tanto, no son del todo coherentes en los resultados que devuelven: una consulta repetida en cualquiera de los sistemas puede devolver resultados diferentes (especialmente en el caso de que haya varias operaciones de eliminación que se ejecutan simultáneamente).</p>
    <p >Los resultados de búsqueda existentes cambian según el estado del fragmento al que se asigna una cuenta; el estado global de un fragmento en particular puede afectar (y lo hace) los resultados de cualquier consulta en particular: Elasticsearch no tiene esta deficiencia.</p>
  </section>
  <section class="bcls-section">
    <h2 id="Examples">Ejemplos</h2>
    <h3>Ejemplo 1</h3>
    <p >Digamos que hay dos videos con los siguientes títulos:</p>
    <pre>
  <code class="language-html" translate="No">Video#1: has the title “Don’t look into the light”
  Video#2: has the title “Using a lighter to make a campfire”</code></pre>
    <p >El usuario desea devolver todos los videos que deben tener la palabra “light”. Con la API de CMS, la consulta tendría el siguiente aspecto:</p>
    <pre>
  <code class="language-html" translate="No">q=%2Blight or q=+light</code></pre>
    <p >Con la búsqueda existente, esto devolverá ambos videos en el orden:</p>
    <pre>
  <code class="language-html" translate="No">Video#2 - “Using a lighter to make a campfire”
  Video#1 - “Don’t look into the light”</code></pre>
    <p >Hay dos problemas con esto:</p>
    <ul>
      <li><strong>Relevancia</strong>: El pedido es incorrecto. "No mires a la luz" (video n. ° 2) debe aparecer antes de "Usar un encendedor para hacer una fogata" (video n. ° 1)</li>
      <li><strong>Precisión</strong>: "Usar un encendedor para hacer una fogata" ni siquiera debería aparecer en el conjunto de resultados, ya que la palabra "luz" no aparece en absoluto en el título del video.</li>
    </ul>
    <p >Con Elasticsearch, esto devolverá solo el video uno:</p>
    <pre>
  <code class="language-html" translate="No">Video#1 - “Don’t look into the light”</code></pre>
    <p >Esto supone una mejora porque:</p>
    <ul>
      <li>Relevancia: El pedido es correcto.</li>
      <li>Precisión: Solo se devuelve el video uno, ya que es el único video con la palabra "light" en el título.</li>
    </ul>
    <h3>Ejemplo 2</h3>
    <p >Como se describe en nuestro <a href="https://apis.support.brightcove.com/cms/searching/cmsplayback-api-videos-search.html#Stemming">Documentación de la API de CMS para la derivación</a> , se admite la derivación, pero no las búsquedas de palabras parciales. Digamos que hay 5 videos con los siguientes títulos:</p>
    <pre>
  <code class="language-html" translate="No">Video#1 - "Parking Ban Announced"
  Video#2 - "Parking to be Banned"
  Video#3 - "City Banning Parking"
  Video#4 - "Bank Holiday"
  Video#5 - "Bandit Captured"</code></pre>
    <p >El usuario desea devolver todos los videos que deben tener la palabra <strong>prohibición</strong> en el campo de nombre. Con la API de CMS, la consulta tendría el siguiente aspecto:</p>
    <pre>
  <code class="language-html" translate="No">q=%2Bname%3Aban or q=+name:ban</code></pre>
    <p >La expectativa es que "Prohibir", "Prohibir" y "Prohibir" producirían resultados de búsqueda, ya que "Prohibir" es una raíz de los tres.</p>
    <p >Sin embargo, con el sistema de búsqueda actual, esto devolverá los cinco videos en este orden:</p>
    <pre>
  <code class="language-html" translate="No">Video#2 - "Parking to be Banned"
  Video#3 - "City Banning Parking"
  Video#1 - "Parking Ban Announced"
  Video#4 - "Bank Holiday"
  Video#5 - "Bandit Captured"</code></pre>
    <p >Nuevamente, hay dos problemas con esto:</p>
    <ul>
      <li>Relevancia: El pedido es incorrecto. "Prohibición de estacionamiento anunciada" debería ser el primer video que se devuelva, ya que tiene la palabra "Prohibición".</li>
      <li>Precisión: "Bank Holiday" y "Bandit Captured" no deben devolverse en absoluto, ya que "Ban" no es parte de la palabra "Bank" o "Bandit".</li>
    </ul>
    <p >Con Elasticsearch, los resultados se ven así:</p>
    <pre>
  <code class="language-html" translate="No">Video#1 - "Parking Ban Announced"
  Video#2 - "Parking to be Banned"
  Video#3 - "City Banning Parking"</code></pre>
    <p >Esto supone una mejora porque:</p>
    <ul>
      <li>Relevancia: El pedido es correcto.</li>
      <li>Precisión: Solo se muestran los videos con la raíz de la palabra "Prohibir" ("Prohibir", "Prohibir" y "Prohibir").</li>
    </ul>
  </section>
</article>